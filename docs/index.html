<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>LazyPredator</title>
    <style>
			body {
             background-color: white;
             font-family: Arial, Helvetica, sans-serif;
           }
      h1 { padding: 0; border: 0; margin: 0; margin-top: 0.2em; }
      h2 { padding: 0; border: 0; margin: 0; margin-top: 0.2em; }
      p { color: black; }
      code { font-size: 120%; }
      pre {
            color: black;
	          border: 1px dashed rgb(65%,65%,65%);
	          padding: 10px;
           	margin-bottom: 1em;
          }
      .wrapping_code {
                       color: black;
                       border: 1px dashed rgb(65%,65%,65%);
                       padding: 10px;
                       margin-bottom: 1em;
                       font-family: Courier, "Courier New", monospace;
                       font-weight: normal;
                       font-size: 83%;
                     }
      .comment { color: rgb(30%,30%,30%); }
      <!-- for in-page date anchors -->
      a.date         {color: rgb(40%,40%,40%); }
			a.date:link    {text-decoration: none; color: rgb(40%,40%,40%);}
			a.date:visited {text-decoration: none; color: rgb(40%,40%,40%);}
			a.date:hover   {text-decoration: underline; color: rgb(40%,40%,40%);}
			a.date:active  {text-decoration: none; color: rgb(40%,40%,40%);}
      .post {
              border-top: 0.3em solid rgb(25%,25%,25%);
              margin-top: 1em;
              padding-left: 2em;
              padding-right: 2em;
              padding-top: 1em;
              clear: left ;
            }
      .designnote { color: rgb(25%,25%,25%) }
      .novak_pad { margin-right: 105px; margin-left: 105px; }
      .smaller { font-size: 75%; }
    <!-- --------------------------------------------------------------------------- -->
    <div class="post" id="yyyymmdd">
      <a href="#yyyymmdd" class="date">Month 0, 0000</a>
      <h1>Title</h1>
      <p>...</p>
      <pre>x</pre>
    </div>
    <!-- --------------------------------------------------------------------------- -->
    </style>
  </head>
  <body id="top">
    <p class="smaller"><a href="https://cwreynolds.github.io/LazyPredator/">This
        page on GitHub</a></p>
    <h1>LazyPredator</h1>
    <p><strong>LazyPredator</strong> is a library for <a href="https://en.wikipedia.org/wiki/Evolutionary_computation">evolutionary
        computation</a>, a type of population-based optimization algorithm. It
      uses <a href="https://en.wikipedia.org/wiki/Generic_programming">genetic
        programming</a> where the individuals of the population are computer
      programs in a “domain specific language”. The relative “fitness” or
      “quality” of these programs is measured in small “tournaments” where the
      programs compete against each other. Using a <a href="https://en.wikipedia.org/wiki/Negative_selection_%28natural_selection%29">negative
        selection</a> approach, the lower fitness individuals of a tournament
      are removed from the population, and replaced by a new “offspring” of the
      tournament's higher fitness individuals. (The offspring is created from
      parents by “cross-over” and “mutation” as described <a href="https://en.wikipedia.org/wiki/Genetic_programming">here</a>.)
      Negative selection implies that lower fitness individuals tend to die
      off—while others tend to survive regardless of rank in the population.
      Selection of participants in a tournament is “uniform” not “fitness
      proportional.” This is the opposite of “elitism” and related practices in
      evolutionary computation where the focus is on identifying and promoting
      high fitness individuals. LazyPredator seeks to encourage “genetic
      drift”—while continuing to prune the low performing individuals—in order
      to gradually improve population fitness.</p>
    <p>The name “LazyPredator” refers to this type of negative selection in
      nature. A lioness may be capable of running down a healthy adult antelope.
      But given the opportunity, she would rather find easier prey (the young,
      or old, or injured) so she can obtain food for her family using less of
      her own energy. Through this action, most of the antelope herd will be
      fit, strong, and fast enough to survive. At the risk of mixing metaphors,
      or at least species, there is a very old joke about this:</p>
    <p style="margin-left: 40px;"> Two campers see a bear running toward them.<br>
      One starts putting on running shoes.<br>
      The other says, “What are you doing?! You can’t outrun a bear!”<br>
      The first says, “I don’t have to outrun the bear—I just have to outrun
      you!”</p>
    <p>LazyPredator is a sibling of <a href="https://cwreynolds.github.io/TexSyn/">TexSyn</a>
      a library for procedural texture synthesis. Together they support
      experiments in adversarial evolutionary texture synthesis. I am especially
      interested in simulating the evolution of camouflage in nature, as in this
      earlier work: <a href="https://www.red3d.com/cwr/iec/">Interactive
        Evolution of Camouflage</a>.</p>
    <p>The code repository for LazyPredator is at <a href="https://github.com/cwreynolds/LazyPredator">GitHub</a>.</p>
    <p>(I'm wondering about the writing style of this notebook. The one for <a
        href="https://cwreynolds.github.io/TexSyn/">TexSyn</a> was largely
      intended to show texture images along with commentary. When possible, I
      tried to avoid coding detail. LazyPredator is about plain old software
      design, so probably there will be more discussion here of lower level
      details of the implementation. On the other hand, I do want it to be more
      prose-like than the terse <code>git commit</code> messages.)</p>
    <br style="##########################################################################">
    <div class="post" id="20201011"> <a href="#20201011" class="date">October
        11, 2020</a>
      <h1>“Jiggle” mutation for numeric leaf values.</h1>
      <p>Based on <a href="#20201010">yesterday's</a> streamlining for ranged
        numeric types, it was pretty easy to add a new “handler function” to <code>GpType</code>
        to provide “jiggle” mutation for the numeric constant values found at
        leaves of <code>GpTree</code>s. Like yesterday, I only supported c++
        concrete types <code>int</code> and <code>float</code>. If others are
        needed they can be added later, or explicitly implemented using the
        older, more general form of <code>GpType</code> constructor. The jiggle
        handler function is automatically constructed for a ranged numeric <code>
          GpType</code>, based on the given range bounds and a parameter
        prototyped as <code>GpType::maxJiggleFactor()</code>. It is currently
        set to 0.05 so at any given jiggle, a value will be offset by up to ±5%
        of the given range. Here is a little test code to watch iterated jiggle
        of an <code>int</code> and <code>float</code> type on the range [0,
        100]:</p>
      <pre>GpType ti("Int", 0, 100);
GpType tf("Float", 0.0f, 100.0f);
std::any vi = 50;
std::any vf = 50.0f;
for (int k = 0; k &lt; 1000; k++)
{
    vi = ti.jiggleConstant(vi);
    vf = tf.jiggleConstant(vf);
    std::cout &lt;&lt; ti.to_string(vi) &lt;&lt; ", ";
    std::cout &lt;&lt; tf.to_string(vf) &lt;&lt; std::endl;
}</pre>
      <p>The result behaves as a “bounded Brownian” series. It stays within the
        given range, covering the entire range, while not hugging the bounds due
        to clipping. I took the log from that code and pasted it into a
        speadsheet for plotting:</p>
      <img src="images/20201011_jiggle_series.png" alt="jiggle series" title="jiggle series"
        height="404" width="1000"> </div>
    <div class="post" id="20201010"> <a href="#20201010" class="date">October
        10, 2020</a>
      <h1><code>GpType</code> constructors: less is more</h1>
      <p>Two key operators in genetic programming are <em>crossover</em> and <em>mutation</em>.
        Crossover has been discussed <a href="#20201008">before</a>. I was
        starting to think about a “point mutation” operator on <code>GpTree</code>s
        that adds noise to numeric parameters in a tree's leaves. This is not
        about that, but was prompted by setting the stage for it. The definition
        of TexSyn's <code>FunctionSet</code> consists of two collection: <code>GpType</code>s
        and <code>GpFunction</code>s. (And now a third parameter for <code>crossover_min_size</code>.)
        Before today, the <code>GpType</code> specs looked like this:<br>
      </p>
      <pre>{<br>    { "<strong>Texture</strong>" },
    { "<strong>Vec2</strong>" },
    {
        "<strong>Float_01</strong>",
        [](){ return std::any(LPRS().frandom01()); },
        any_to_string&lt;float&gt;
    },
    {
        "<strong>Float_02</strong>",
        [](){ return std::any(LPRS().frandom2(0, 2)); },
        any_to_string&lt;float&gt;
    },
    {
        "<strong>Float_0_10</strong>",
        [](){ return std::any(LPRS().frandom2(0, 10)); },
        any_to_string&lt;float&gt;
    },
    {
        "<strong>Float_m5p5</strong>",
        [](){ return std::any(LPRS().frandom2(-5, 5)); },
        any_to_string&lt;float&gt;
    }<br>}</pre>
      <p>I have been glossing over this format for <code>GpType</code>
        constructors, since it felt a little preliminary. <code>Texture</code>
        and <code>Vec2</code> are used only as tags to correctly matching up
        inputs and outputs of <code>GpFunction</code>s. The other four types
        are specializations of the concrete <code>c++</code> type <code>float</code>.
        These four types differ only in the range of values they represent. For
        example, <code>Float_01</code> are values on the interval [0.0, 1.0]
        and <code>Float_m5p5</code> are values on the interval [-5.0, 5.0]. For
        each <code>GpType</code> “initializer list” (between braces <code>{}</code>)
        there is: (1) a character string name, (2) a function to return a random
        “ephemeral constant” uniformly selected from the type's range, and (3) a
        function that casts from a value of this type to a character string for
        printing. (The values actually passed around are of type <code>std::any</code>
        for “type erasure” but let's not get into that right now.)</p>
      <p>I came up with a way to make this less messy. I hope eventually that
        LazyPredator will be used for other applications. For now however, it is
        only being used with the <code>FunctionSet</code> for TexSyn. So this
        may be short-sighted, but so far, a <code>GpType</code> either just
        tags an instance of a c++ class (like <code>Texture</code> and <code>Vec2</code>)
        or it represents a numeric type, perhaps with range constraints (like <code>Float_01</code>
        ... <code>Float_m5p5</code>). So rather than writing out the two (soon
        to be three) handler functions/lambdas, all we need to specify are the
        ranges. I defined two new constructors for <code>GpType</code> one for
        float and one for int that takes: a name, range_min, and range_max. The
        internal structure of a <code>GpType</code> object is unchanged, this
        is just a different way to initialize its internal state. The result is
        a much more compact specification for the <code>GpType</code>s of a <code>FunctionSet</code>:</p>
      <pre>{<br>    { "<strong>Texture</strong>" },
    { "<strong>Vec2</strong>" },
    { "<strong>Float_01</strong>", 0.0f, 1.0f },
    { "<strong>Float_02</strong>", 0.0f, 2.0f },
    { "<strong>Float_0_10</strong>", 0.0f, 10.0f },
    { "<strong>Float_m5p5</strong>", -5.0f, 5.0f }<br>}</pre>
      <p>I like this approach. The connection with mutation operators is that
        soon there would have been need for a fourth item in <code>GpType</code>'s
        initializer list: a function to “jiggle” an existing value of this type.
        Having defined a <code>GpType</code> as a ranged numeric value, we can
        automatically generate the handlers for randomizing, printing, and soon,
        for mutating. The older constructors remain available for cases not
        covered by this streamlining.</p>
    </div>
    <div class="post" id="20201008"> <a href="#20201008" class="date">October
        8, 2020</a>
      <h1>Minimum size for crossover snippet</h1>
      <p>I am developing LazyPredator and TexSyn in parallel, so sometimes its
        hard to decide which “blog” should get a post. Recent work with GP
        crossover was been reported in TexSyn's posts on <a href="https://cwreynolds.github.io/TexSyn/#20201003">October
          3</a> and <a href="https://cwreynolds.github.io/TexSyn/#20201005">October
          5</a> (and previously on this page on <a href="#20200930">September
          30</a>). The topic of the <a href="https://cwreynolds.github.io/TexSyn/#20201005">October
          5</a> post, and this one, is the question of whether random “crossover
        points” in a pair of parent GP trees should be selected uniformly across
        all nodes in the trees. I think this is the most common and
        “traditional” approach. But I decided to allow a variation on this which
        seems useful in a concrete case like TexSyn's <code>FunctionSet</code>.</p>
      <p>The GP tree crossover operation is based on selecting, in two “parent”
        trees, a pair of nodes. Those two nodes are the roots of two subtrees,
        which can be thought of as a snippet of code in normal linear textual
        code notation. We copy the selected subtree of the “donor” tree, and
        paste it over the subtree of the “recipient”/offspring tree.</p>
      <p>But let's back up a bit, how is the random selection of a node in each
        tree defined? In the <a href="https://cwreynolds.github.io/TexSyn/#20201003">October
          3</a> examples this was done in what I consider the “traditional” way:
        a recursive traversal of the tree is made and a reference to each
        node/subtree is stored in an array (in this case an <code>std::vector</code>),
        then a random index over the size of the array is generated and the
        corresponding subtree is selected. (Equivalently without the array: one
        traversal measures the size of the tree, the random index is determined,
        then a second traversal is made until it reaches the node corresponding
        to that index, which is returned.) This means that the selection of tree
        nodes is uniformly distributed over all nodes in the tree.</p>
      <p>Because LazyPredator is based on STGP (strongly typed genetic
        programming) there is an additional constraint that the two selected
        subtrees have the same type (<code>GpType</code>). This is accomplished
        by first selecting a node in the “donor” tree, then filtering the nodes
        of the “recipient” tree to consider only subtrees with a matching type.</p>
      <p>Consider this (partially redacted) <code>FunctionSet</code>. It shares
        a property with TexSyn that the root type (<code>Thing</code>) has no
        “ephemeral constants”, while the other type (<code>Int</code>) has no
        operators, appearing only as numeric constant leaf nodes:</p>
      <pre>FunctionSet fs =
{
    <span class="comment">// GpTypes:</span>
    {
        {
            "Thing", nullptr, any_to_string&lt;...&gt;
        },
        {
            "Int", [](){ return std::any(int(LPRS().randomN(10))); }, any_to_string&lt;int&gt;
        }
    },
    <span class="comment">// GpFunctions:</span>
    {
        {
            "This", "Thing", {"Thing", "Thing"}, [](const GpTree&amp; t) { ... }
        },
        {
            "That", "Thing", {"Thing", "Thing"}, ](const GpTree&amp; t) { ... }
        },
        {
            "Other", "Thing", {"Int", "Int"}, [](const GpTree&amp; t) { ... }
        }
    }
};</pre>
      <p>This is a typical random <code>GpTree</code>, of size 55, created by
        that <code>FunctionSet</code> with 28 numeric constant leaf nodes (in
        red):</p>
      <pre>This(Other(<span style="color: red;">9</span>, <span style="color: red;">0</span>),
     That(This(This(This(Other(<span style="color: red;">8</span>, <span style="color: red;">2</span>),
                         This(Other(<span style="color: red;">5</span>, <span style="color: red;">9</span>),
                              Other(<span style="color: red;">3</span>, <span style="color: red;">8</span>))),
                    Other(<span style="color: red;">3</span>, <span style="color: red;">1</span>)),
               That(This(This(Other(<span style="color: red;">6</span>, <span style="color: red;">1</span>),
                              Other(<span style="color: red;">8</span>, <span style="color: red;">1</span>)),
                         Other(<span style="color: red;">4</span>, <span style="color: red;">0</span>)),
                    This(Other(<span style="color: red;">3</span>, <span style="color: red;">2</span>),
                         That(This(Other(<span style="color: red;">9</span>, <span
style="color: red;">4</span>),
                                   Other(<span style="color: red;">6</span>, <span
style="color: red;">9</span>)),
                              This(Other(<span style="color: red;">6</span>, <span
style="color: red;">4</span>),
                                   Other(<span style="color: red;">1</span>, <span
style="color: red;">9</span>)))))),
          Other(<span style="color: red;">9</span>, <span style="color: red;">6</span>)))</pre>
      <p>Note that 28/55 or about 51% of random nodes (selected uniformly) will
        be these numeric constants. So given two <code>GpTrees</code> from this
        <code>FunctionSet</code>, roughly half of all crossover operations will
        consist of moving a single numeric constant from one tree to the other.
        (Recall that in STGP, <code>Int</code>s from one tree can only
        crossover to <code>Int</code>s in the other tree.) About half the
        crossover operations will do nothing but parameter “tweaking” and in a
        way that ignores the context that would normally exist when a larger
        subtree is moved. I would prefer that “tweaking” constant leaf values be
        done by point mutation, which is defined to make “small” changes in
        value.</p>
      <p>Consider instead this version of that FunctionSet, identical but with
        the new <code>crossover_min_size</code> parameter added at the bottom:</p>
      <pre>FunctionSet fs =
{
    <span class="comment">// GpTypes:</span>
    {
        ...
    },
    <span class="comment">// GpFunctions:</span>
    {
        ...
    },
    <span class="comment">// Min_size for crossover:</span>
    <strong>2</strong>
};</pre>
      <p>By increasing the <code>crossover_min_size</code> to <strong>2</strong>
        from its default of <strong>1</strong>, this requires that all
        crossover subtrees/snippets must be of size <strong>2</strong> or
        larger. Specifically this means that a single numeric constant leaf
        value (of size 1) is <strong>excluded</strong> from selection as the
        crossover subtree/snippet. (As mentioned above, this is accomplished by
        filtering the set of candidate subtrees, in this case by size.) The
        effect of this is that all crossover snippets must consist of subtrees
        larger than a single leaf node. In terms of the random program above:
        all of the red leaf nodes are excluded, and the selection must be one of
        the larger subtrees in black. In the examples shown in TexSyn's blog for
        <a href="https://cwreynolds.github.io/TexSyn/#20201005">October 5</a>, a
        <code>crossover_min_size</code> of <strong>5</strong> is used, implying
        that the crossover snippet must be larger than the minimal (size 4) <code>Texture</code>
        generator of <code>Uniform(r, g, b)</code>, a “texture” of uniform
        color.</p>
    </div>
    <div class="post" id="20200930"> <a href="#20200930" class="date">September
        30, 2020</a>
      <h1>Crossover of <code>GpTrees</code> — wait, that was <em>too</em> easy</h1>
      <p>In biology <a href="https://en.wikipedia.org/wiki/Chromosomal_crossover">chromosomal
          crossover</a> is a key mechanism where the DNA of two parents is
        combined to produce a unique offspring. Two corresponding strands of
        parental DNA are “scanned” in parallel, with one or the other being
        copied into the new offspring's DNA. During this “scan” the source of
        the offspring's DNA changes “randomly” from one parent to the other. (If
        you are a biologist, please forgive this over-simplified probably
        incorrect description.)</p>
      <p>In genetic programming there is an analogous “crossover” operation on
        program trees. When describing GP I often call this “random syntax-aware
        copy-and-paste.” It is as if a subtree (subexpression) from one parent's
        program is <em>copied</em>, then <em>pasted</em> into (a copy of) the
        other parent's program, replacing a preexisting subtree (subexpression).
        This creates a new offspring program with part of its code from one
        parent and part of its code from the other parent. LazyPredator
        implements “strongly typed genetic programming” so there is the
        additional constraint that the type of the two subtrees must match. (In
        TexSyn, most of the subtrees are of type <code>Texture</code>, but some
        subtrees return <code>Vec2</code> or numeric <code>float</code>
        values.)</p>
      <p>Crossover had been on the to-do list for a while and I finally got
        around to working on it. I defined a new test <code>FunctionSet</code>
        whose terminals are all single digit integers, and whose functions
        belong to two families: P, PP, PPP, Q, QQ, and QQQ. Here is that <code>FunctionSet</code>'s
        self description:</p>
      <pre>1 GpTypes: 
GpType: Int, min size to terminate: 1, has ephemeral generator, has to_string, functions returning this type: P, PP, PPP, Q, QQ, QQQ.

6 GpFunctions: 
GpFunction: P, return_type: Int, parameters: (Int).
GpFunction: PP, return_type: Int, parameters: (Int, Int).
GpFunction: PPP, return_type: Int, parameters: (Int, Int, Int).
GpFunction: Q, return_type: Int, parameters: (Int).
GpFunction: QQ, return_type: Int, parameters: (Int, Int).
GpFunction: QQQ, return_type: Int, parameters: (Int, Int, Int).</pre>
      <p>I also added a mechanism to <code>FunctionSet</code> allowing a filter
        to be specified on the available functions. Here are randomly created
        program trees drawn from the two sets:</p>
      <pre><span class="comment">// makeRandomTree() called with function filter allowing only the P family:</span>
PPP(PPP(P(7), P(P(1)), PP(4, 3)), P(PPP(P(8), P(P(0)), PP(8, 4))), PPP(P(P(1)), P(P(6)), P(P(7))))

<span class="comment">// makeRandomTree() called with function filter allowing only the Q family:</span>
QQQ(Q(QQQ(Q(7), Q(2), QQ(5, 8))), Q(QQQ(Q(5), QQ(5, 3), Q(Q(3)))), QQQ(QQ(3, 4), QQ(6, 1), QQ(8, 1)))</pre>
      <p>Then I manually selected a subtree from each of those <code>GpTrees</code>:</p>
      <pre><span class="comment">// gp_tree_p.getSubtree(0):</span>
<strong>PPP(P(7), P(P(1)), PP(4, 3))</strong>

<span class="comment">// gp_tree_q.getSubtree(2):</span>
<strong>QQQ(QQ(3, 4), QQ(6, 1), QQ(8, 1))</strong></pre>
      <p>Then I assigned one to the other:</p>
      <pre>gp_tree_p.getSubtree(0) = gp_tree_q.getSubtree(2);</pre>
      <p><em>Et voila!:</em></p>
      <pre>PPP(<strong>QQQ(QQ(3, 4), QQ(6, 1), QQ(8, 1))</strong>, P(PPP(P(8), P(P(0)), PP(8, 4))), PPP(P(P(1)), P(P(6)), P(P(7))))</pre>
      <p>Writing that again with indentation and color to highlight the
        subtrees:</p>
      <pre><span class="comment">// The P tree with it first subtree selected:</span>
<span style="color:red">PPP(<strong>PPP(P(7), P(P(1)), PP(4, 3))</strong>,
    P(PPP(P(8), P(P(0)), PP(8, 4))),
    PPP(P(P(1)), P(P(6)), P(P(7))))</span>

<span class="comment">// The Q tree with it third subtree selected:</span>
<span style="color:blue">QQQ(Q(QQQ(Q(7), Q(2), QQ(5, 8))),
    Q(QQQ(Q(5), QQ(5, 3), Q(Q(3)))),
    <strong>QQQ(QQ(3, 4), QQ(6, 1), QQ(8, 1))</strong>)</span>

<span class="comment">// The offspring tree with some of both:</span>
<span style="color:red">PPP(<span style="color:blue"><strong>QQQ(QQ(3, 4), QQ(6, 1), QQ(8, 1))</strong></span>,
    P(PPP(P(8), P(P(0)), PP(8, 4))),
    PPP(P(P(1)), P(P(6)), P(P(7))))</span></pre>
    </div>
    <div class="post" id="20200921"> <a href="#20200921" class="date">September
        21, 2020</a>
      <h1>Runtime connection between LazyPredator and TexSyn</h1>
      <p>[<strong>Update on September 29, 2020: </strong>after some further
        revisions, I made a “first final” <code>FunctionSet</code> for TexSyn.
        The code below is both incomplete and slightly outdated. To see the
        “modern” <code>FunctionSet</code> for TexSyn in this source code: <a href="https://github.com/cwreynolds/TexSyn/blob/60acd34866634d1c3d69f04e0ae53cf3760b4b3c/GP.h">GP.h</a>
        (assuming I did that right, it should be a permalink to the revision of
        GP.h as of September 29 on GitHub.)]</p>
      <p>Finally LazyPredator and TexSyn are talking together at runtime! I had
        mocked this up back on <a href="https://cwreynolds.github.io/TexSyn/#20200815">August
          15</a> by having prototype <code>FunctionSet:makeRandomTree()</code>
        print out the “source code” of generated trees, then hand editing that
        into a test jig in TexSyn and rendering the textures. Now it is actually
        working, directly evaluating the <code>GpTree</code> and then passing
        that result to TexSyn's render utility. See renderings in today's the <a
          href="https://cwreynolds.github.io/TexSyn/#20200921">TexSyn log</a>.</p>
      <p>I was not looking forward to the software engineering of making
        LazyPredator into a proper linkable library. Instead I took the path
        that is becoming more popular, especially for libraries of modest size
        like LazyPredator: I made it a <a href="https://stackoverflow.com/questions/12671383/benefits-of-header-only-libraries">header-only
          library</a>. Then “linking” it to TexSyn was merely a matter of adding
        the directive <code>#include "LazyPredator.h"</code>.</p>
      <p>I wrote a subset of the <code>FunctionSet</code> definition for TexSyn
        (similar to an earlier prototype in LP called <code>TestFS::tinyTexSyn()</code>)
        for testing. It supports <code>GpTypes</code> for <code>Texture</code>
        pointers, <code>Vec2</code> values, and <code>Float_01</code> values.
        It provides two <code>GpFunction</code>s as <code>Texture</code>
        operators : <code>Uniform</code> and <code>Spot</code>:</p>
      <pre>const FunctionSet tiny_texsyn =<br>{
    {
        {"Texture"},
        {"Vec2"},
        {
            "Float_01",
            [](){ return std::any(LPRS().frandom01()); },
            any_to_string&lt;float&gt;
        }
    },
    {
        {
            "Vec2",
            "Vec2",
            {"Float_01", "Float_01"},
            [](const GpTree&amp; tree)
            {
                return std::any(Vec2(tree.evalSubtree&lt;float&gt;(0),
                                     tree.evalSubtree&lt;float&gt;(1)));
            }
        },
        
        {
            "Uniform",
            "Texture",
            {"Float_01", "Float_01", "Float_01"},
            [](const GpTree&amp; tree)
            {
                Texture* t = new Uniform(tree.evalSubtree&lt;float&gt;(0),
                                         tree.evalSubtree&lt;float&gt;(1),
                                         tree.evalSubtree&lt;float&gt;(2));
                return std::any(t);
            }
        },
        
        {
            "Spot",
            "Texture",
            {"Vec2", "Float_01", "Texture", "Float_01", "Texture"},
            [](const GpTree&amp; tree)
            {
                Texture* t = new Spot(tree.evalSubtree&lt;Vec2&gt;(0),
                                      tree.evalSubtree&lt;float&gt;(1),
                                      *tree.evalSubtree&lt;Texture*&gt;(2),
                                      tree.evalSubtree&lt;float&gt;(3),
                                      *tree.evalSubtree&lt;Texture*&gt;(4));
                return std::any(t);
            }
        },
    }<br>};</pre>
      <p>The next step is to build these out to include the ~50 Texture
        operators in TexSyn.</p>
    </div>
    <div class="post" id="20200919"> <a href="#20200919" class="date">September
        19, 2020</a>
      <h1>Tweaks to <code>FunctionSet</code></h1>
      <p>Well that exploded quickly! I noticed that the recording of <code>GpType</code>
        with a constant “leaf” value in a <code>GpTree</code> was wrong, which
        was going undetected, and ultimately not mattering. The latter—that the
        <code>GpType</code> is redundant since it can be inferred from the
        parent <code>GpTree</code> node—is an issue to consider later. However
        if the value is stored it ought to be correct. It either needed to be
        error checked (which it now is, at least in the unit test) or set in
        sync with the tree's root function or leaf value are set. I changed <code>GpTree::setFunction()</code>
        and <code>GpTree::setLeafValue()</code> to record a <code>GpType</code>
        in the <code>GpTree</code>'s root.</p>
      <p>Or that was what I did after I fixed the <em>other</em> bug I ran
        into. Sample <code>FunctionSet</code>s are defined in <code>TestFS</code>.
        Those are immutable <code>const</code> references. I had been copying
        those because previously <code>FunctionSet</code> assumed it could
        mutate itself. So I made several changes to allow <code>FunctionSet</code>s
        to remain immutable. Part of that was to move a <code>RandomSequence</code>
        object from inside <code>FunctionSet</code> out to global scope, now
        accessed as <code>LPRS()</code>. That also needs to be reconsidered.
        Maybe it should belong to <code>Population</code> class or something
        else. In any case, the point is to have restartable random number
        sequences when that is helpful for testing or debugging.</p>
      <p>I was also concerned that there were four nearly identical short
        functions in <code>FunctionSet</code>: <code>const</code> and non-<code>const</code>
        versions of <code>lookupGpTypeByName()</code> and <code>lookupGpFunctionByName()</code>.
        In fact their bodies were exactly identical, the differences were <code>const</code>-ness
        of the functions and their return values. I tried making their bodies a
        common function, then a common template, then finally fell back to a
        common preprocessor macro. Not pretty, but some times you just need to
        turn off type checking.</p>
      <p>Finally, since its role is to create a random <code>GpTree</code>, I
        renamed <code>FunctionSet</code>'s <code>makeRandomProgram()</code> to
        <code>makeRandomTree()</code>.</p>
    </div>
    <div class="post" id="20200915"> <a href="#20200915" class="date">September
        15, 2020</a>
      <h1>Tree evaluation to construct procedural models</h1>
      <p>The <a href="#20200907">previous post</a> demonstrated evaluating GP
        trees to produce a numeric result. This is easier when all tree nodes
        have numeric values (or other “plain old data” (POD) types). It is more
        complicated when the values in a tree represent data structures or
        abstractions like class instances. It is trivial to copy (say) a numeric
        value, but the cost of copying a composite object can be significantly
        higher to handle the data and procedural state of an object. (As a
        concrete example, during initialization, TexSyn's <em>LotsOfSpots</em>
        texture operator builds a moderate-sized data set and runs a relaxation
        procedure on it.) So generally, we need to be able to pass
        “references”/“pointers” to these larger objects in addition to copying
        “plain old data” types (and small instances: TexSyn routinely copies <em>Vec2</em>
        objects whose entire state is just two floats).</p>
      <p>LazyPredator is being built to optimize TexSyn procedural texture
        models. In this mode of use, GP programs are evaluated to <strong>construct</strong>
        a secondary representation, here a tree of TexSyn texture operator
        instances (plus 2d vectors and numbers). From a c++ point of view, the
        GP tree represents a deeply nested expression consisting of class <strong>constructors</strong>.
        Evaluating that expression builds the various texture operators, using
        the supplied parameters, some of which are themselves newly constructed
        texture operators. Once built these procedural texture models can be
        used to render the texture for display or file output, or to place the
        texture into evolutionary competition with other textures.</p>
      <p>To test this capability I made a toy example (analogous to but separate
        from TexSyn) based on these three classes:</p>
      <pre>class ClassA
{
public:
    ClassA(const ClassB&amp; b, ClassC c) : b_(b), c_(c) {}
    ...
private:
    const ClassB&amp; b_;
    const ClassC c_;
};<br><br>class ClassB
{
public:
    ClassB(float f) : f_(f) {}
    ...
private:
    float f_;
};

class ClassC
{
public:
    ClassC(int i, int j) : i_(i), j_(j) {}
    ...
private:
    int i_;
    int j_;
};</pre>
      <p>Note that <code>ClassA</code>'s first parameter is a <code>ClassB</code>
        instance passed by <strong>reference</strong> and its second parameter
        is a <code>ClassC</code> instance passed by <strong>value</strong>.
        The new <code>UnitTests::gp_tree_eval_objects()</code> uses the <code>FunctionSet</code>
        from <code>TestFS::treeEvalObjects()</code> to construct, then
        evaluate, this tree:</p>
      <pre>ClassA(ClassB(0.5), ClassC(1, 2))</pre>
      <p>It then verifies that the <code>ClassA</code> instance constructed is
        valid, contains a reference to a valid instance of <code>ClassB</code>
        and a copy of a valid <code>ClassC</code> instance, and all have the
        expected internal state.</p>
      <p>New <code>UnitTests::gp_tree_eval_simple()</code> similarly tests
        evaluation of <code>GpTree</code>s with numeric values.</p>
    </div>
    <div class="post" id="20200907"> <a href="#20200907" class="date">September
        7, 2020</a>
      <h1>Evaluating program trees</h1>
      <p>Today I finally got past a roadblock which held me up for a week. The
        code to generate a random program was working well, and the <code>GpTree</code>
        containers were solid. But I had not yet connected my abstract <code>GpFunction</code>s
        and <code>GpType</code>s to the “real world” of c++ types. This would
        be required to support “evaluation”/“execution” of the <code>GpTree</code>.</p>
      <p>Generally in c++ when you want to parameterize something by types, you
        use a “template.” As I had been working along, I assumed I would derive
        templated versions of <code> GpFunction</code>s and <code>GpType</code>s
        to accommodate the concrete c++ types. There were problems with that,
        chiefly that “template virtual functions” are <em>not a thing</em>. I
        tried several refactorings but none allowed me to generalize over the
        set of concrete types. I even considered “hiding” the types inside an
        abstraction where they were stored as <code>void*</code> / <code>std::shared_ptr&lt;void&gt;</code>
        pointers, with the required “casting” to concrete types on the way in
        and out. Of course that is not “type safe” so a bug can lead to bizarre
        “undefined behavior.”</p>
      <p>While reading about that I discovered that the <code>c++17</code>
        standard introduced a new “meta type” called <code>std::any</code>. It
        is nearly identical to the <code>void*</code> trick, while keeping
        track of the type of the data behind the blind pointer for error
        checking, and being fully supported by the language and compiler. Yay!
        So now the <code>GpTree</code> keeps track of values of arbitrary c++
        types via type <code>std::any</code>. The <code> GpType</code>s and <code>GpFunction</code>s
        “know” the concrete types, so provide the transformations via <code>std::any_cast&lt;T&gt;(A)</code>
        which casts <code>A</code>, an <code>std::any</code>, to a value of
        concrete type <code>T</code>. One consequence of this is that
        LazyPredator <em>requires</em> <code>c++17</code> (whereas before, <code>c++11</code>
        was good enough).</p>
      <p>For a simple example, imagine a <code>FunctionSet</code> consisting of
        two types and these five functions:</p>
      <pre>Int AddInt(Int a, Int b) {…}
Float AddFloat(Float a, Float b) {…}
Int Floor(Float a) {…}
Float Sqrt(Int a) {…}
Float Mult(Float a, Int b) {…}</pre>
      <p>In the code, this is currently written like this. The <code>FunctionSet</code>
        takes a collection of <code>GpType</code>s and one of <code>GpFunction</code>s.
        Each takes “helper functions” (lambdas, function pointers, callbacks)
        that handle casting, generating ephemeral constants and evaluating
        concrete functions. (So for example, <code>AddInt</code> is passed a
        reference to some node in a <code>GpTree</code>, it evaluates the
        subtrees corresponding to its parameters, casts those to concrete types,
        applies its own underlying function to them, and returns the result as
        an <code>std::any</code>):</p>
      <pre>FunctionSet <strong>test_tree_eval</strong> =
{
    <span class="comment">// GpTypes (with ephemeral constant generatorss, and to_string handlers).<br></span>    {
        {
            "<strong>Int</strong>",
            [](){ return std::any(int(rand() % 10)); },
            any_to_string&lt;int&gt;
        },
        {
            "<strong>Float</strong>",
            [](){ return std::any(frandom01()); },
            any_to_string&lt;float&gt;
        }
    },<br>    <span class="comment">// GpFunctions (with a lambda</span><span class="comment"> to apply function to </span><span
class="comment"><span class="comment">parameter via </span>a GpTree)</span>
    {
        {
            "<strong>AddInt</strong>", "Int", {"Int", "Int"}, [](const GpTree&amp; t)
            {
                return std::any(t.evalSubtree&lt;int&gt;(0) + t.evalSubtree&lt;int&gt;(1));
            }
        },
        {
            "<strong>AddFloat</strong>", "Float", {"Float", "Float"}, [](const GpTree&amp; t)
            {
                return std::any(t.evalSubtree&lt;float&gt;(0) + t.evalSubtree&lt;float&gt;(1));
            }
        },
        {
            "<strong>Floor</strong>", "Int", {"Float"}, [](const GpTree&amp; t)
            {
                return std::any(int(std::floor(t.evalSubtree&lt;float&gt;(0))));
            }
        },
        {
            "<strong>Sqrt</strong>", "Float", {"Int"}, [](const GpTree&amp; t)
            {
                return std::any(float(std::sqrt(t.evalSubtree&lt;int&gt;(0))));
            }
        },
        {
            "<strong>Mult</strong>", "Float", {"Float", "Int"}, [](const GpTree&amp; t)
            {
                return std::any(t.evalSubtree&lt;float&gt;(0) * t.evalSubtree&lt;int&gt;(1));
            }
        }
    }
};</pre>
      <p>Using that <code>FunctionSet</code>, called <code>test_tree_eval</code>,
        here is a random program of size 10, whose value is 3.60555: </p>
      <p class="wrapping_code">Sqrt(AddInt(AddInt(6, Floor(0.262453)), AddInt(7,
        Floor(0.736082))))</p>
      <p>And here is a random program of size 100, whose value is 74.2361:</p>
      <p class="wrapping_code">AddFloat(Mult(Mult(AddFloat(AddFloat(Sqrt(4),
        Sqrt(0)), Sqrt(Floor(Mult(0.081061, 5)))),
        Floor(AddFloat(AddFloat(Sqrt(7), Sqrt(5)), Mult(Sqrt(0),
        Floor(0.269215))))), Floor(AddFloat(Mult(AddFloat(Sqrt(4), Sqrt(7)),
        Floor(AddFloat(0.776866, Sqrt(4)))),
        AddFloat(Sqrt(Floor(AddFloat(0.422460, 0.282156))),
        Sqrt(Floor(AddFloat(0.193967, 0.011316))))))),
        AddFloat(Sqrt(Floor(Mult(Mult(Mult(0.191824, Floor(0.983236)),
        Floor(AddFloat(0.244054, Sqrt(1)))), Floor(Mult(Sqrt(AddInt(8, 5)),
        AddInt(Floor(0.601010), Floor(0.176880))))))),
        AddFloat(Sqrt(AddInt(AddInt(Floor(0.828355), Floor(0.157731)),
        AddInt(Floor(0.987937), Floor(0.257169)))),
        Sqrt(Floor(AddFloat(Sqrt(Floor(Sqrt(7))), AddFloat(Sqrt(7),
        Sqrt(3))))))))</p>
    </div>
    <div class="post" id="20200829"> <a href="#20200829" class="date">August
        29, 2020</a>
      <h1>Progress on <code>GpTree</code></h1>
      <p>A dirty little secret of <code>FunctionSet::makeRandomProgram()</code>
        was that it did not <em>actually</em> “make” a program. It had been
        just going through the motions, and printing out a textual
        representation of the program it <em>would</em> be making, if only
        there was an internal representation of programs. Now there is <code>GpTree</code>
        which I have been building out for a few days, adding tools for building
        and accessing them. A <code>FunctionSet</code> is defined as a grammar
        in terms of <code>GpType</code> and <code>GpFunction</code>. Now <code>FunctionSet::makeRandomProgram()</code>
        stores its result in a <code>GpTree</code> object. They have a <code>GpTree::size()</code>
        function which had previously been handled by <code>makeRandomProgram()</code>.
        Similarly <code>GpTree::to_string()</code> does a translation to
        “source code” as an <code>std::string</code>, mostly for debugging and
        logging.</p>
      <p>The <code>FunctionSet</code> for TexSyn is particularly simple: all
        function returns <code>Texture</code>, except <code>Vec2</code>, and
        the only other component is <code>float</code> constants. I had not
        initially handled the case where a <code>GpType</code> can be supplied
        by either a “leaf” constant <strong>or</strong> a subtree of functions.
        So I defined a little <code> FunctionSet</code> that had that issue:</p>
      <pre>FunctionSet fs = {
                     {
                         {"Int", [](){ return rand() % 10; }}  // GpType "Int" with "ephemeral generator".
                     },
                     {
                         {"Ant", "Int", {"Int", "Int"}},       // GpFunction "Ant", returns Int, takes two Int parameters.
                         {"Bat", "Int", {"Int", "Int"}},       // GpFunction "Bat", returns Int, takes two Int parameters.
                         {"Cat", "Int", {"Int"}}               // GpFunction "Cat", returns Int, takes one Int parameter.
                     }
                 };</pre>
      <p>Initially all random programs generated from this set consisted of
        exactly one <code>Int</code> constant. After making the fix to allow a
        type to be return by both functions and “ephemeral constants”, it
        produced trees of the given size (here 50):</p>
      <pre>Cat(Cat(Cat(Ant(Cat(Cat(Bat(Bat(Ant(4, Cat(7)), Ant(Cat(4), Cat(4))),
                            Cat(Cat(Bat(Bat(4, 8), Cat(Cat(Cat(8))))))))),
                Cat(Bat(Ant(Ant(1, Cat(7)), Ant(Cat(3), Cat(2))),
                        Ant(Bat(Cat(0), Cat(9)), Cat(Bat(7, Cat(4))))))))))</pre>
    </div>
    <div class="post" id="20200824"> <a href="#20200824" class="date">August
        24, 2020</a>
      <h1>Component types <code>GpType</code> and <code>GpFunction</code></h1>
      <p>I rewrote the prototype <code>FunctionSet::makeRandomProgram()</code>
        to be less ugly. Chiefly I made new abstractions, <code>GpType</code>
        and <code>GpFunction</code>, to represent types and functions of the GP
        <code>FunctionSet</code>. I added a new constructor for <code>FunctionSet</code>
        which allows the whole set of types and functions to be defined in a
        single expression. Before a lot of analysis of the function set (e.g.
        which functions return a value of this type?) was repeated each time it
        was needed. Now it all gets done once, in the new constructor, and
        cached. Similarly a lot of looking up character string names in maps has
        been replaced with direct pointers. </p>
      <p>I also refactored the two pre-defined FunctionSets for testing: <code>tiny_texsyn</code>
        and <code>full_texsyn</code>.</p>
    </div>
    <div class="post" id="20200817"> <a href="#20200817" class="date">August
        17, 2020</a>
      <h1>Size control fixed for random programs</h1>
      <p>I tracked down the bug(s) that prevented exact control of the maximum
        size of GP programs constructed by <code>FunctionSet::makeRandomProgram()</code>.&nbsp;
        Now, generating a series of programs (here for the TexSyn <code>FunctionSet</code>)
        produces mostly programs of the given max_size (which is 50 in these
        examples), some slightly smaller, and occasionally much smaller. I have
        not decided if I care about the minimum size of these programs.</p>
      <p class="wrapping_code"><span class="comment">// size=50</span> <br>
        Colorize(Vec2(3.337209, -0.111232), Vec2(-1.048723, 2.609511),
        SliceToRadial(Vec2(-0.735182, 2.328732), Vec2(2.607049, 4.752589),
        Blur(0.763175, Gamma(4.788119, EdgeDetect(0.303196, Blur(0.725915,
        Gamma(1.888874, Uniform(0.645293, 0.362680, 0.187303))))))),
        EdgeEnhance(0.566709, 0.395660, Min(BrightnessToHue(0.227292,
        EdgeDetect(0.088983, Uniform(0.432841, 0.452565, 0.759366))),
        Blur(0.878352, AdjustSaturation(0.648826, EdgeDetect(0.192719,
        Uniform(0.464628, 0.675937, 0.744247))))))) <br>
        <br>
        <span class="comment">// size=50</span> <br>
        LotsOfSpots(0.012097, 0.135414, 0.751684, 0.965764, 0.281318,
        LotsOfSpots(0.147613, 0.588885, 0.570666, 0.800021, 0.687004,
        AdjustSaturation(0.277342, EdgeDetect(0.894000, Uniform(0.127598,
        0.188189, 0.893133))), Blur(0.093948, Gamma(3.296728, Uniform(0.652457,
        0.482005, 0.737463)))), LotsOfButtons(0.797039, 0.144344, 0.208901,
        0.213856, 0.829122, Vec2(-1.575197, 1.251038), Uniform(0.904293,
        0.052319, 0.090617), 0.854814, ColorNoise(Vec2(3.118072, 1.187010),
        Vec2(-0.589404, 2.754478), 0.299059))) <br>
        <br>
        <span class="comment">// size=49</span> <br>
        Wrap(-3.596494, Vec2(0.694285, 0.919086), Vec2(0.989166, -4.823082),
        SliceShear(Vec2(-0.120761, -2.569393), Vec2(-0.134178, 1.804898),
        EdgeDetect(0.959444, Gamma(6.956436, Uniform(0.111692, 0.197541,
        0.677295))), Vec2(2.580718, 0.258248), Vec2(3.048599, -3.998405),
        Min(BrightnessWrap(0.183154, 0.216393, EdgeEnhance(0.937688, 0.592261,
        Uniform(0.792651, 0.186018, 0.810909))), AbsDiff(Uniform(0.830450,
        0.310026, 0.461115), Uniform(0.473002, 0.195799, 0.609615))))) <br>
        <br>
        <span class="comment"><span class="comment">// size=8</span> <br>
          ColorNoise(Vec2(4.320298, 0.666899), Vec2(2.787325, 4.352788),
          0.550106) <br>
          <br>
          <span class="comment"></span>// size=50</span> <br>
        Multiply(Gamma(9.301153, EdgeDetect(0.117543, HueOnly(0.059045,
        0.402121, Add(ColorNoise(Vec2(-0.885789, -2.376529), Vec2(4.686641,
        -0.853005), 0.158803), ColorNoise(Vec2(-0.682632, -3.960764),
        Vec2(0.204911, -0.370719), 0.662522))))), SliceGrating(Vec2(0.915037,
        3.041960), Vec2(-3.293618, 4.275027), SoftMatte(Uniform(0.031453,
        0.989732, 0.696574), Blur(0.835575, Uniform(0.979765, 0.764766,
        0.473790)), BrightnessWrap(0.012443, 0.341328, Uniform(0.533497,
        0.499851, 0.642036))))) <br>
        <br>
        <span class="comment">// size=20</span> <br>
        AdjustSaturation(0.066990, Ring(4.104012, Vec2(-2.495622, 0.238659),
        Vec2(0.829247, -3.823189), AdjustBrightness(0.070340,
        ColorNoise(Vec2(-0.894583, 2.009082), Vec2(-4.681360, -2.824072),
        0.809685)))) <br>
        <br>
        <span class="comment">// size=4</span> <br>
        Uniform(0.912225, 0.591371, 0.169519) <br>
        <br>
        <span class="comment">// size=49</span> <br>
        LotsOfButtons(0.522967, 0.333162, 0.085013, 0.728105, 0.668366,
        Vec2(1.857913, -2.245440), ColorNoise(Vec2(-0.412046, -3.319272),
        Vec2(-4.977819, 2.511291), 0.610481), 0.917300, AdjustHue(0.857817,
        SoftMatte(Min(Uniform(0.211855, 0.353225, 0.061723), Uniform(0.792557,
        0.015160, 0.339307)), Max(Uniform(0.163184, 0.786264, 0.147327),
        Uniform(0.351334, 0.191037, 0.729921)), AdjustSaturation(0.686154,
        ColorNoise(Vec2(0.018567, 4.154261), Vec2(3.782207, 4.571167),
        0.044231))))) <br>
        <br>
        <span class="comment">// size=50</span> <br>
        Ring(5.741549, Vec2(-0.906608, -4.878014), Vec2(2.884423, -3.600070),
        ColoredSpots(0.678892, 0.553492, 0.929361, 0.208069, 0.767077,
        CotsMap(Vec2(-3.395577, -0.600270), Vec2(2.026988, -3.274830),
        Vec2(0.036533, -4.649998), Vec2(2.966635, 1.534505), Uniform(0.527436,
        0.518428, 0.101204)), Grating(Vec2(-1.834993, -0.729365),
        Uniform(0.231773, 0.243197, 0.261381), Vec2(2.077976, -3.491028),
        Uniform(0.279188, 0.504817, 0.897037), 0.532966, 0.978290)))</p>
    </div>
    <div class="post" id="20200815"> <a href="#20200815" class="date">August
        15, 2020</a>
      <h1>Prototype <code>FunctionSet</code> covering entire TexSyn API</h1>
      <p>Yesterday I plowed through the entire TexSyn API converting it into the
        prototype <code>FunctionSet</code> format. This includes 52 <code>Texture</code>
        operators, plus <code>Vec2</code>, plus several “ephemeral constants”
        for various random distributions of floating point values. This allowed
        procedural construction of random TexSyn programs. <code>FunctionSet::makeRandomProgram()</code>
        is still very much a prototype implementation, and still has a bug
        controlling program size. But I could at least print out the text of
        these random programs, then cut-and-paste that into TexSyn for
        rendering. Some samples of textures generated by these random programs
        are in <a href="https://cwreynolds.github.io/TexSyn/#20200815">today's
          entry in TexSyn's log</a>.</p>
    </div>
    <div class="post" id="20200813"> <a href="#20200813" class="date">August
        13, 2020</a>
      <h1>Making random programs</h1>
      <p>I've been prototyping a <code>FunctionSet</code> class to represent
        the “domain specific language” manipulated by genetic programming.
        LazyPredator implements <em>strongly typed genetic programming</em>
        where the values of <em>function</em> and <em>terminals</em>, and the
        parameters to <em>functions</em>, all have associated <em>types</em>.
        I made a simple API for adding definitions of the <em>types</em> and
        the <em>functions</em> used in the “domain specific language”. These
        use prototype underpinnings, just enough scaffolding to begin developing
        additional functionality. After I “rough out” a working <code>FunctionSet</code>
        class, and so better understand the requirements, I will refactor the
        underlying <code>FunctionSet</code> structure to be more clean and
        efficient.</p>
      <p>To initialize a GP population we need a utility—here called <code>FunctionSet::makeRandomProgram()</code>—to
        generate a “random program” in the “domain specific language” (aka a
        grammar) defined by a <code>FunctionSet</code> instance. By “random
        program” I mean a random <em>expression</em>, a composition of <em>functions</em>
        and <em>terminals</em> which, when evaluated, produce a value. <code>makeRandomProgram()</code>
        is further parameterized by a <code>max_size</code> for the generated
        programs. This size is measured as the count of function names and <em>
          terminals</em> such as numeric constants (and potentially input <em>variables</em>,
        but that is not currently supported).</p>
      <p>This post is to mark that my prototype <code>makeRandomProgram()</code>
        is now generating random programs that are no longer obviously wrong. I
        made a toy <code>FunctionSet</code> corresponding to a tiny subset of <a
          href="https://cwreynolds.github.io/TexSyn/">TexSyn</a>. The <em>functions</em>
        are drawn from: <code>Vec2</code>, <code>Uniform</code>, <code>Affine</code>,
        <code>Multiply</code>, and <code>Scale</code>. The <em>terminals</em>
        are <code>float</code> “ephemeral constants” whose values are randomly
        initialized. Here are a couple of “random programs” of size 20:</p>
      <pre>Scale(-1.89065,
      Affine(Vec2(2.71928, 1.51213),
             Vec2(-2.15447, 3.58087),
             Multiply(Scale(-0.46497,
                            Uniform(0.270371, 0.544808, 0.653164)),
                      Uniform(0.582032, 0.0811457, 0.593893))))

Affine(Vec2(1.62775, 0.925812),
       Vec2(0.892051, -2.5576),
       Scale(-3.9347,
             Affine(Vec2(1.14234, 0.321014),
                    Vec2(3.70146, 3.92498),
                    Uniform(0.842375, 0.46032, 0.180332))))</pre>
      <p>These are of course gibberish, not only because they are “random” but
        because this tiny function set is unable to express anything
        interesting. One important problem with the current code is that there
        is a bug in the control of program size. The <code>max_size</code>
        parameter is intended to be a strict upper bound. Instead <code>FunctionSet</code><code>::makeRandomProgram()</code>
        generates programs whose sizes are distributed “in the vicinity of” <code>max_size</code>.
        That is at least better than a recent version that generated programs up
        to size 1000.</p>
    </div>
    <div class="post" id="20200807"> <a href="#20200807" class="date">August 7,
        2020</a>
      <h1>Monitor lifetime of <code>Individual</code> in <code>Population</code></h1>
      <p>My vague plan is that the <code>Population</code> class will handle
        all aspects of <code>Individual</code>s. A <code>Population</code>
        instance will generate the initial collection of random programs. It
        will randomly select the individuals to participate in a tournament. It
        will form offspring from tournament winners, remove the losers, and
        replace them with the offspring. </p>
      <p>One important bit of “owning” the individuals is that they must be
        properly allocated and de-allocated. I gave the <code>Individual</code>
        class a counter which gets incremented in the constructor and
        decremented in the destructor. </p>
      <p>I made the first unit test which ensures that this count is initially
        zero, then constructing a <code>Population</code> with <em>n</em> <code>Individual</code>s
        causes it to be n, and that deleting the <code>Population</code> causes
        it to go back to zero. Right now it only tests the initial creation of
        (“mock”) <code>Individual</code>s, later the unit test should include
        running tournaments.</p>
    </div>
    <div class="post" id="20200806"> <a href="#20200806" class="date">August 6,
        2020</a>
      <h1>Getting started, stubs for <code>Population</code>, <code>Individual</code>,
        and <code>UnitTests</code></h1>
      <p>Just starting to rough out the components of the system. Today it is a
        class for an evolutionary <code>Population</code> and the <code>Individual</code>s
        in it. Also a namespace for <code>UnitTests</code> with a goal of using
        “test driven development.”</p>
    </div>
    <div class="post" id="0">
      <p>This page, and the software it describes, by <a href="https://www.red3d.com/cwr">Craig
          Reynolds</a></p>
    </div>
  </body>
</html>
