<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>LazyPredator</title>
    <style>
			body {
             background-color: white;
             font-family: Arial, Helvetica, sans-serif;
           }
      h1 { padding: 0; border: 0; margin: 0; margin-top: 0.2em; }
      h2 { padding: 0; border: 0; margin: 0; margin-top: 0.2em; }
      p { color: black; }
      code { font-size: 120%; }
      pre {
            color: black;
	          border: 1px dashed rgb(65%,65%,65%);
	          padding: 10px;
           	margin-bottom: 1em;
          }
      .wrapping_code {
                       color: black;
                       border: 1px dashed rgb(65%,65%,65%);
                       padding: 10px;
                       margin-bottom: 1em;
                       font-family: Courier, "Courier New", monospace;
                       font-weight: normal;
                       font-size: 83%;
                     }
      .comment { color: rgb(30%,30%,30%); }
      <!-- for in-page date anchors -->
      a.date         {color: rgb(40%,40%,40%); }
			a.date:link    {text-decoration: none; color: rgb(40%,40%,40%);}
			a.date:visited {text-decoration: none; color: rgb(40%,40%,40%);}
			a.date:hover   {text-decoration: underline; color: rgb(40%,40%,40%);}
			a.date:active  {text-decoration: none; color: rgb(40%,40%,40%);}
      .post {
              border-top: 0.3em solid rgb(25%,25%,25%);
              margin-top: 1em;
              padding-left: 2em;
              padding-right: 2em;
              padding-top: 1em;
              clear: left ;
            }
      .designnote { color: rgb(25%,25%,25%) }
      .novak_pad { margin-right: 105px; margin-left: 105px; }
      .smaller { font-size: 75%; }
    <!-- --------------------------------------------------------------------------- -->
    <div class="post" id="yyyymmdd">
      <a href="#yyyymmdd" class="date">Month 0, 0000</a>
      <h1>Title</h1>
      <p>...</p>
      <pre>x</pre>
    </div>
    <!-- --------------------------------------------------------------------------- -->
    </style>
  </head>
  <body id="top">
    <p class="smaller"><a href="https://cwreynolds.github.io/LazyPredator/">This
        page on GitHub</a></p>
    <h1>LazyPredator</h1>
    <p><strong>LazyPredator</strong> is a library for <a href="https://en.wikipedia.org/wiki/Evolutionary_computation">evolutionary
        computation</a>, a type of population-based optimization algorithm. It
      uses <a href="https://en.wikipedia.org/wiki/Generic_programming">genetic
        programming</a> where the individuals of the population are computer
      programs in a “domain specific language”. The relative “fitness” or
      “quality” of these programs is measured in small “tournaments” where the
      programs compete against each other. Using a <a href="https://en.wikipedia.org/wiki/Negative_selection_%28natural_selection%29">negative
        selection</a> approach, the lower fitness individuals of a tournament
      are removed from the population, and replaced by a new “offspring” of the
      tournament's higher fitness individuals. (The offspring is created from
      parents by “cross-over” and “mutation” as described <a href="https://en.wikipedia.org/wiki/Genetic_programming">here</a>.)
      Negative selection implies that lower fitness individuals tend to die
      off—while others tend to survive regardless of rank in the population.
      Selection of participants in a tournament is “uniform” not “fitness
      proportional.” This is the opposite of “elitism” and related practices in
      evolutionary computation where the focus is on identifying and promoting
      high fitness individuals. LazyPredator seeks to encourage “genetic
      drift”—while continuing to prune the low performing individuals—in order
      to gradually improve population fitness.</p>
    <p>The name “LazyPredator” refers to this type of negative selection in
      nature. A lioness may be capable of running down a healthy adult antelope.
      But given the opportunity, she would rather find easier prey (the young,
      or old, or injured) so she can obtain food for her family using less of
      her own energy. Through this action, most of the antelope herd will be
      fit, strong, and fast enough to survive. At the risk of mixing metaphors,
      or at least species, there is a very old joke about this:</p>
    <p style="margin-left: 40px;"> Two campers see a bear running toward them.<br>
      One starts putting on running shoes.<br>
      The other says, “What are you doing?! You can’t outrun a bear!”<br>
      The first says, “I don’t have to outrun the bear—I just have to outrun
      you!”</p>
    <p>LazyPredator is a sibling of <a href="https://cwreynolds.github.io/TexSyn/">TexSyn</a>
      a library for procedural texture synthesis. Together they support
      experiments in adversarial evolutionary texture synthesis. I am especially
      interested in simulating the evolution of camouflage in nature, as in this
      earlier work: <a href="https://www.red3d.com/cwr/iec/">Interactive
        Evolution of Camouflage</a>.</p>
    <p>The code repository for LazyPredator is at <a href="https://github.com/cwreynolds/LazyPredator">GitHub</a>.</p>
    <p>(I'm wondering about the writing style of this notebook. The one for <a
        href="https://cwreynolds.github.io/TexSyn/">TexSyn</a> was largely
      intended to show texture images along with commentary. When possible, I
      tried to avoid coding detail. LazyPredator is about plain old software
      design, so probably there will be more discussion here of lower level
      details of the implementation. On the other hand, I do want it to be more
      prose-like than the terse <code>git commit</code> messages.)</p>
    <br style="##########################################################################">
    <div class="post" id="20200915"> <a href="#20200915" class="date">September
        15, 2020</a>
      <h1>Tree evaluation to construct procedural models</h1>
      <p>The <a href="#20200907">previous post</a> demonstrated evaluating GP
        trees to produce a numeric result. This is easier when all tree nodes
        have numeric values (or other “plain old data” (POD) types). It is more
        complicated when the values in a tree represent data structures or
        abstractions like class instances. It is trivial to copy (say) a numeric
        value, but the cost of copying a composite object can be significantly
        higher to handle the data and procedural state of an object. (As a
        concrete example, during initialization, TexSyn's <em>LotsOfSpots</em>
        texture operator builds a moderate-sized data set and runs a relaxation
        procedure on it.) So generally, we need to be able to pass
        “references”/“pointers” to these larger objects in addition to copying
        “plain old data” types (and small instances: TexSyn routinely copies <em>Vec2</em>
        objects whose entire state is just two floats).</p>
      <p>LazyPredator is being built to optimize TexSyn procedural texture
        models. In this mode of use, GP programs are evaluated to <strong>construct</strong>
        a secondary representation, here a tree of TexSyn texture operator
        instances (plus 2d vectors and numbers). From a c++ point of view, the
        GP tree represents a deeply nested expression consisting of class <strong>constructors</strong>.
        Evaluating that expression builds the various texture operators, using
        the supplied parameters, some of which are themselves newly constructed
        texture operators. Once built these procedural texture models can be
        used to render the texture for display or file output, or to place the
        texture into evolutionary competition with other textures.</p>
      <p>To test this capability I made a toy example (analogous to but separate
        from TexSyn) based on these three classes:</p>
      <pre>class ClassA
{
public:
    ClassA(const ClassB&amp; b, ClassC c) : b_(b), c_(c) {}
    ...
private:
    const ClassB&amp; b_;
    const ClassC c_;
};<br><br>class ClassB
{
public:
    ClassB(float f) : f_(f) {}
    ...
private:
    float f_;
};

class ClassC
{
public:
    ClassC(int i, int j) : i_(i), j_(j) {}
    ...
private:
    int i_;
    int j_;
};</pre>
      <p>Note that <code>ClassA</code>'s first parameter is a <code>ClassB</code>
        instance passed by <strong>reference</strong> and its second parameter
        is a <code>ClassC</code> instance passed by <strong>value</strong>.
        The new <code>UnitTests::gp_tree_eval_objects()</code> uses the <code>FunctionSet</code>
        from <code>TestFS::treeEvalObjects()</code> to construct, then
        evaluate, this tree:</p>
      <pre>ClassA(ClassB(0.5), ClassC(1, 2))</pre>
      <p>It then verifies that the <code>ClassA</code> instance constructed is
        valid, contains a reference to a valid instance of <code>ClassB</code>
        and a copy of a valid <code>ClassC</code> instance, and all have the
        expected internal state.</p>
      <p>New <code>UnitTests::gp_tree_eval_simple()</code> similarly tests
        evaluation of <code>GpTree</code>s with numeric values.</p>
    </div>
    <div class="post" id="20200907"> <a href="#20200907" class="date">September
        7, 2020</a>
      <h1>Evaluating program trees</h1>
      <p>Today I finally got past a roadblock which held me up for a week. The
        code to generate a random program was working well, and the <code>GpTree</code>
        containers were solid. But I had not yet connected my abstract <code>GpFunction</code>s
        and <code>GpType</code>s to the “real world” of c++ types. This would
        be required to support “evaluation”/“execution” of the <code>GpTree</code>.</p>
      <p>Generally in c++ when you want to parameterize something by types, you
        use a “template.” As I had been working along, I assumed I would derive
        templated versions of <code> GpFunction</code>s and <code>GpType</code>s
        to accommodate the concrete c++ types. There were problems with that,
        chiefly that “template virtual functions” are <em>not a thing</em>. I
        tried several refactorings but none allowed me to generalize over the
        set of concrete types. I even considered “hiding” the types inside an
        abstraction where they were stored as <code>void*</code> / <code>std::shared_ptr&lt;void&gt;</code>
        pointers, with the required “casting” to concrete types on the way in
        and out. Of course that is not “type safe” so a bug can lead to bizarre
        “undefined behavior.”</p>
      <p>While reading about that I discovered that the <code>c++17</code>
        standard introduced a new “meta type” called <code>std::any</code>. It
        is nearly identical to the <code>void*</code> trick, while keeping
        track of the type of the data behind the blind pointer for error
        checking, and being fully supported by the language and compiler. Yay!
        So now the <code>GpTree</code> keeps track of values of arbitrary c++
        types via type <code>std::any</code>. The <code> GpType</code>s and <code>GpFunction</code>s
        “know” the concrete types, so provide the transformations via <code>std::any_cast&lt;T&gt;(A)</code>
        which casts <code>A</code>, an <code>std::any</code>, to a value of
        concrete type <code>T</code>. One consequence of this is that
        LazyPredator <em>requires</em> <code>c++17</code> (whereas before, <code>c++11</code>
        was good enough).</p>
      <p>For a simple example, imagine a <code>FunctionSet</code> consisting of
        two types and these five functions:</p>
      <pre>Int AddInt(Int a, Int b) {…}
Float AddFloat(Float a, Float b) {…}
Int Floor(Float a) {…}
Float Sqrt(Int a) {…}
Float Mult(Float a, Int b) {…}</pre>
      <p>In the code, this is currently written like this. The <code>FunctionSet</code>
        takes a collection of <code>GpType</code>s and one of <code>GpFunction</code>s.
        Each takes “helper functions” (lambdas, function pointers, callbacks)
        that handle casting, generating ephemeral constants and evaluating
        concrete functions. (So for example, <code>AddInt</code> is passed a
        reference to some node in a <code>GpTree</code>, it evaluates the
        subtrees corresponding to its parameters, casts those to concrete types,
        applies its own underlying function to them, and returns the result as
        an <code>std::any</code>):</p>
      <pre>FunctionSet <strong>test_tree_eval</strong> =
{
    <span class="comment">// GpTypes (with ephemeral constant generatorss, and to_string handlers).<br></span>    {
        {
            "<strong>Int</strong>",
            [](){ return std::any(int(rand() % 10)); },
            any_to_string&lt;int&gt;
        },
        {
            "<strong>Float</strong>",
            [](){ return std::any(frandom01()); },
            any_to_string&lt;float&gt;
        }
    },<br>    <span class="comment">// GpFunctions (with a lambda</span><span class="comment"> to apply function to </span><span
class="comment"><span class="comment">parameter via </span>a GpTree)</span>
    {
        {
            "<strong>AddInt</strong>", "Int", {"Int", "Int"}, [](const GpTree&amp; t)
            {
                return std::any(t.evalSubtree&lt;int&gt;(0) + t.evalSubtree&lt;int&gt;(1));
            }
        },
        {
            "<strong>AddFloat</strong>", "Float", {"Float", "Float"}, [](const GpTree&amp; t)
            {
                return std::any(t.evalSubtree&lt;float&gt;(0) + t.evalSubtree&lt;float&gt;(1));
            }
        },
        {
            "<strong>Floor</strong>", "Int", {"Float"}, [](const GpTree&amp; t)
            {
                return std::any(int(std::floor(t.evalSubtree&lt;float&gt;(0))));
            }
        },
        {
            "<strong>Sqrt</strong>", "Float", {"Int"}, [](const GpTree&amp; t)
            {
                return std::any(float(std::sqrt(t.evalSubtree&lt;int&gt;(0))));
            }
        },
        {
            "<strong>Mult</strong>", "Float", {"Float", "Int"}, [](const GpTree&amp; t)
            {
                return std::any(t.evalSubtree&lt;float&gt;(0) * t.evalSubtree&lt;int&gt;(1));
            }
        }
    }
};</pre>
      <p>Using that <code>FunctionSet</code>, called <code>test_tree_eval</code>,
        here is a random program of size 10, whose value is 3.60555: </p>
      <p class="wrapping_code">Sqrt(AddInt(AddInt(6, Floor(0.262453)), AddInt(7,
        Floor(0.736082))))</p>
      <p>And here is a random program of size 100, whose value is 74.2361:</p>
      <p class="wrapping_code">AddFloat(Mult(Mult(AddFloat(AddFloat(Sqrt(4),
        Sqrt(0)), Sqrt(Floor(Mult(0.081061, 5)))),
        Floor(AddFloat(AddFloat(Sqrt(7), Sqrt(5)), Mult(Sqrt(0),
        Floor(0.269215))))), Floor(AddFloat(Mult(AddFloat(Sqrt(4), Sqrt(7)),
        Floor(AddFloat(0.776866, Sqrt(4)))),
        AddFloat(Sqrt(Floor(AddFloat(0.422460, 0.282156))),
        Sqrt(Floor(AddFloat(0.193967, 0.011316))))))),
        AddFloat(Sqrt(Floor(Mult(Mult(Mult(0.191824, Floor(0.983236)),
        Floor(AddFloat(0.244054, Sqrt(1)))), Floor(Mult(Sqrt(AddInt(8, 5)),
        AddInt(Floor(0.601010), Floor(0.176880))))))),
        AddFloat(Sqrt(AddInt(AddInt(Floor(0.828355), Floor(0.157731)),
        AddInt(Floor(0.987937), Floor(0.257169)))),
        Sqrt(Floor(AddFloat(Sqrt(Floor(Sqrt(7))), AddFloat(Sqrt(7),
        Sqrt(3))))))))</p>
    </div>
    <div class="post" id="20200829"> <a href="#20200829" class="date">August
        29, 2020</a>
      <h1>Progress on <code>GpTree</code></h1>
      <p>A dirty little secret of <code>FunctionSet::makeRandomProgram()</code>
        was that it did not <em>actually</em> “make” a program. It had been
        just going through the motions, and printing out a textual
        representation of the program it <em>would</em> be making, if only
        there was an internal representation of programs. Now there is <code>GpTree</code>
        which I have been building out for a few days, adding tools for building
        and accessing them. A <code>FunctionSet</code> is defined as a grammar
        in terms of <code>GpType</code> and <code>GpFunction</code>. Now <code>FunctionSet::makeRandomProgram()</code>
        stores its result in a <code>GpTree</code> object. They have a <code>GpTree::size()</code>
        function which had previously been handled by <code>makeRandomProgram()</code>.
        Similarly <code>GpTree::to_string()</code> does a translation to
        “source code” as an <code>std::string</code>, mostly for debugging and
        logging.</p>
      <p>The <code>FunctionSet</code> for TexSyn is particularly simple: all
        function returns <code>Texture</code>, except <code>Vec2</code>, and
        the only other component is <code>float</code> constants. I had not
        initially handled the case where a <code>GpType</code> can be supplied
        by either a “leaf” constant <strong>or</strong> a subtree of functions.
        So I defined a little <code> FunctionSet</code> that had that issue:</p>
      <pre>FunctionSet fs = {
                     {
                         {"Int", [](){ return rand() % 10; }}  // GpType "Int" with "ephemeral generator".
                     },
                     {
                         {"Ant", "Int", {"Int", "Int"}},       // GpFunction "Ant", returns Int, takes two Int parameters.
                         {"Bat", "Int", {"Int", "Int"}},       // GpFunction "Bat", returns Int, takes two Int parameters.
                         {"Cat", "Int", {"Int"}}               // GpFunction "Cat", returns Int, takes one Int parameter.
                     }
                 };</pre>
      <p>Initially all random programs generated from this set consisted of
        exactly one <code>Int</code> constant. After making the fix to allow a
        type to be return by both functions and “ephemeral constants”, it
        produced trees of the given size (here 50):</p>
      <pre>Cat(Cat(Cat(Ant(Cat(Cat(Bat(Bat(Ant(4, Cat(7)), Ant(Cat(4), Cat(4))),
                            Cat(Cat(Bat(Bat(4, 8), Cat(Cat(Cat(8))))))))),
                Cat(Bat(Ant(Ant(1, Cat(7)), Ant(Cat(3), Cat(2))),
                        Ant(Bat(Cat(0), Cat(9)), Cat(Bat(7, Cat(4))))))))))</pre>
    </div>
    <div class="post" id="20200824"> <a href="#20200824" class="date">August
        24, 2020</a>
      <h1>Component types <code>GpType</code> and <code>GpFunction</code></h1>
      <p>I rewrote the prototype <code>FunctionSet::makeRandomProgram()</code>
        to be less ugly. Chiefly I made new abstractions, <code>GpType</code>
        and <code>GpFunction</code>, to represent types and functions of the GP
        <code>FunctionSet</code>. I added a new constructor for <code>FunctionSet</code>
        which allows the whole set of types and functions to be defined in a
        single expression. Before a lot of analysis of the function set (e.g.
        which functions return a value of this type?) was repeated each time it
        was needed. Now it all gets done once, in the new constructor, and
        cached. Similarly a lot of looking up character string names in maps has
        been replaced with direct pointers. </p>
      <p>I also refactored the two pre-defined FunctionSets for testing: <code>tiny_texsyn</code>
        and <code>full_texsyn</code>.</p>
    </div>
    <div class="post" id="20200817"> <a href="#20200817" class="date">August
        17, 2020</a>
      <h1>Size control fixed for random programs</h1>
      <p>I tracked down the bug(s) that prevented exact control of the maximum
        size of GP programs constructed by <code>FunctionSet::makeRandomProgram()</code>.&nbsp;
        Now, generating a series of programs (here for the TexSyn <code>FunctionSet</code>)
        produces mostly programs of the given max_size (which is 50 in these
        examples), some slightly smaller, and occasionally much smaller. I have
        not decided if I care about the minimum size of these programs.</p>
      <p class="wrapping_code"><span class="comment">// size=50</span> <br>
        Colorize(Vec2(3.337209, -0.111232), Vec2(-1.048723, 2.609511),
        SliceToRadial(Vec2(-0.735182, 2.328732), Vec2(2.607049, 4.752589),
        Blur(0.763175, Gamma(4.788119, EdgeDetect(0.303196, Blur(0.725915,
        Gamma(1.888874, Uniform(0.645293, 0.362680, 0.187303))))))),
        EdgeEnhance(0.566709, 0.395660, Min(BrightnessToHue(0.227292,
        EdgeDetect(0.088983, Uniform(0.432841, 0.452565, 0.759366))),
        Blur(0.878352, AdjustSaturation(0.648826, EdgeDetect(0.192719,
        Uniform(0.464628, 0.675937, 0.744247))))))) <br>
        <br>
        <span class="comment">// size=50</span> <br>
        LotsOfSpots(0.012097, 0.135414, 0.751684, 0.965764, 0.281318,
        LotsOfSpots(0.147613, 0.588885, 0.570666, 0.800021, 0.687004,
        AdjustSaturation(0.277342, EdgeDetect(0.894000, Uniform(0.127598,
        0.188189, 0.893133))), Blur(0.093948, Gamma(3.296728, Uniform(0.652457,
        0.482005, 0.737463)))), LotsOfButtons(0.797039, 0.144344, 0.208901,
        0.213856, 0.829122, Vec2(-1.575197, 1.251038), Uniform(0.904293,
        0.052319, 0.090617), 0.854814, ColorNoise(Vec2(3.118072, 1.187010),
        Vec2(-0.589404, 2.754478), 0.299059))) <br>
        <br>
        <span class="comment">// size=49</span> <br>
        Wrap(-3.596494, Vec2(0.694285, 0.919086), Vec2(0.989166, -4.823082),
        SliceShear(Vec2(-0.120761, -2.569393), Vec2(-0.134178, 1.804898),
        EdgeDetect(0.959444, Gamma(6.956436, Uniform(0.111692, 0.197541,
        0.677295))), Vec2(2.580718, 0.258248), Vec2(3.048599, -3.998405),
        Min(BrightnessWrap(0.183154, 0.216393, EdgeEnhance(0.937688, 0.592261,
        Uniform(0.792651, 0.186018, 0.810909))), AbsDiff(Uniform(0.830450,
        0.310026, 0.461115), Uniform(0.473002, 0.195799, 0.609615))))) <br>
        <br>
        <span class="comment"><span class="comment">// size=8</span> <br>
          ColorNoise(Vec2(4.320298, 0.666899), Vec2(2.787325, 4.352788),
          0.550106) <br>
          <br>
          <span class="comment"></span>// size=50</span> <br>
        Multiply(Gamma(9.301153, EdgeDetect(0.117543, HueOnly(0.059045,
        0.402121, Add(ColorNoise(Vec2(-0.885789, -2.376529), Vec2(4.686641,
        -0.853005), 0.158803), ColorNoise(Vec2(-0.682632, -3.960764),
        Vec2(0.204911, -0.370719), 0.662522))))), SliceGrating(Vec2(0.915037,
        3.041960), Vec2(-3.293618, 4.275027), SoftMatte(Uniform(0.031453,
        0.989732, 0.696574), Blur(0.835575, Uniform(0.979765, 0.764766,
        0.473790)), BrightnessWrap(0.012443, 0.341328, Uniform(0.533497,
        0.499851, 0.642036))))) <br>
        <br>
        <span class="comment">// size=20</span> <br>
        AdjustSaturation(0.066990, Ring(4.104012, Vec2(-2.495622, 0.238659),
        Vec2(0.829247, -3.823189), AdjustBrightness(0.070340,
        ColorNoise(Vec2(-0.894583, 2.009082), Vec2(-4.681360, -2.824072),
        0.809685)))) <br>
        <br>
        <span class="comment">// size=4</span> <br>
        Uniform(0.912225, 0.591371, 0.169519) <br>
        <br>
        <span class="comment">// size=49</span> <br>
        LotsOfButtons(0.522967, 0.333162, 0.085013, 0.728105, 0.668366,
        Vec2(1.857913, -2.245440), ColorNoise(Vec2(-0.412046, -3.319272),
        Vec2(-4.977819, 2.511291), 0.610481), 0.917300, AdjustHue(0.857817,
        SoftMatte(Min(Uniform(0.211855, 0.353225, 0.061723), Uniform(0.792557,
        0.015160, 0.339307)), Max(Uniform(0.163184, 0.786264, 0.147327),
        Uniform(0.351334, 0.191037, 0.729921)), AdjustSaturation(0.686154,
        ColorNoise(Vec2(0.018567, 4.154261), Vec2(3.782207, 4.571167),
        0.044231))))) <br>
        <br>
        <span class="comment">// size=50</span> <br>
        Ring(5.741549, Vec2(-0.906608, -4.878014), Vec2(2.884423, -3.600070),
        ColoredSpots(0.678892, 0.553492, 0.929361, 0.208069, 0.767077,
        CotsMap(Vec2(-3.395577, -0.600270), Vec2(2.026988, -3.274830),
        Vec2(0.036533, -4.649998), Vec2(2.966635, 1.534505), Uniform(0.527436,
        0.518428, 0.101204)), Grating(Vec2(-1.834993, -0.729365),
        Uniform(0.231773, 0.243197, 0.261381), Vec2(2.077976, -3.491028),
        Uniform(0.279188, 0.504817, 0.897037), 0.532966, 0.978290)))</p>
    </div>
    <div class="post" id="20200815"> <a href="#20200815" class="date">August
        15, 2020</a>
      <h1>Prototype <code>FunctionSet</code> covering entire TexSyn API</h1>
      <p>Yesterday I plowed through the entire TexSyn API converting it into the
        prototype <code>FunctionSet</code> format. This includes 52 <code>Texture</code>
        operators, plus <code>Vec2</code>, plus several “ephemeral constants”
        for various random distributions of floating point values. This allowed
        procedural construction of random TexSyn programs. <code>FunctionSet::makeRandomProgram()</code>
        is still very much a prototype implementation, and still has a bug
        controlling program size. But I could at least print out the text of
        these random programs, then cut-and-paste that into TexSyn for
        rendering. Some samples of textures generated by these random programs
        are in <a href="https://cwreynolds.github.io/TexSyn/#20200815">today's
          entry in TexSyn's log</a>.</p>
    </div>
    <div class="post" id="20200813"> <a href="#20200813" class="date">August
        13, 2020</a>
      <h1>Making random programs</h1>
      <p>I've been prototyping a <code>FunctionSet</code> class to represent
        the “domain specific language” manipulated by genetic programming.
        LazyPredator implements <em>strongly typed genetic programming</em>
        where the values of <em>function</em> and <em>terminals</em>, and the
        parameters to <em>functions</em>, all have associated <em>types</em>.
        I made a simple API for adding definitions of the <em>types</em> and
        the <em>functions</em> used in the “domain specific language”. These
        use prototype underpinnings, just enough scaffolding to begin developing
        additional functionality. After I “rough out” a working <code>FunctionSet</code>
        class, and so better understand the requirements, I will refactor the
        underlying <code>FunctionSet</code> structure to be more clean and
        efficient.</p>
      <p>To initialize a GP population we need a utility—here called <code>FunctionSet::makeRandomProgram()</code>—to
        generate a “random program” in the “domain specific language” (aka a
        grammar) defined by a <code>FunctionSet</code> instance. By “random
        program” I mean a random <em>expression</em>, a composition of <em>functions</em>
        and <em>terminals</em> which, when evaluated, produce a value. <code>makeRandomProgram()</code>
        is further parameterized by a <code>max_size</code> for the generated
        programs. This size is measured as the count of function names and <em>
          terminals</em> such as numeric constants (and potentially input <em>variables</em>,
        but that is not currently supported).</p>
      <p>This post is to mark that my prototype <code>makeRandomProgram()</code>
        is now generating random programs that are no longer obviously wrong. I
        made a toy <code>FunctionSet</code> corresponding to a tiny subset of <a
          href="https://cwreynolds.github.io/TexSyn/">TexSyn</a>. The <em>functions</em>
        are drawn from: <code>Vec2</code>, <code>Uniform</code>, <code>Affine</code>,
        <code>Multiply</code>, and <code>Scale</code>. The <em>terminals</em>
        are <code>float</code> “ephemeral constants” whose values are randomly
        initialized. Here are a couple of “random programs” of size 20:</p>
      <pre>Scale(-1.89065,
      Affine(Vec2(2.71928, 1.51213),
             Vec2(-2.15447, 3.58087),
             Multiply(Scale(-0.46497,
                            Uniform(0.270371, 0.544808, 0.653164)),
                      Uniform(0.582032, 0.0811457, 0.593893))))

Affine(Vec2(1.62775, 0.925812),
       Vec2(0.892051, -2.5576),
       Scale(-3.9347,
             Affine(Vec2(1.14234, 0.321014),
                    Vec2(3.70146, 3.92498),
                    Uniform(0.842375, 0.46032, 0.180332))))</pre>
      <p>These are of course gibberish, not only because they are “random” but
        because this tiny function set is unable to express anything
        interesting. One important problem with the current code is that there
        is a bug in the control of program size. The <code>max_size</code>
        parameter is intended to be a strict upper bound. Instead <code>FunctionSet</code><code>::makeRandomProgram()</code>
        generates programs whose sizes are distributed “in the vicinity of” <code>max_size</code>.
        That is at least better than a recent version that generated programs up
        to size 1000.</p>
    </div>
    <div class="post" id="20200807"> <a href="#20200807" class="date">August 7,
        2020</a>
      <h1>Monitor lifetime of <code>Individual</code> in <code>Population</code></h1>
      <p>My vague plan is that the <code>Population</code> class will handle
        all aspects of <code>Individual</code>s. A <code>Population</code>
        instance will generate the initial collection of random programs. It
        will randomly select the individuals to participate in a tournament. It
        will form offspring from tournament winners, remove the losers, and
        replace them with the offspring. </p>
      <p>One important bit of “owning” the individuals is that they must be
        properly allocated and de-allocated. I gave the <code>Individual</code>
        class a counter which gets incremented in the constructor and
        decremented in the destructor. </p>
      <p>I made the first unit test which ensures that this count is initially
        zero, then constructing a <code>Population</code> with <em>n</em> <code>Individual</code>s
        causes it to be n, and that deleting the <code>Population</code> causes
        it to go back to zero. Right now it only tests the initial creation of
        (“mock”) <code>Individual</code>s, later the unit test should include
        running tournaments.</p>
    </div>
    <div class="post" id="20200806"> <a href="#20200806" class="date">August 6,
        2020</a>
      <h1>Getting started, stubs for <code>Population</code>, <code>Individual</code>,
        and <code>UnitTests</code></h1>
      <p>Just starting to rough out the components of the system. Today it is a
        class for an evolutionary <code>Population</code> and the <code>Individual</code>s
        in it. Also a namespace for <code>UnitTests</code> with a goal of using
        “test driven development.”</p>
    </div>
    <div class="post" id="0">
      <p>This page, and the software it describes, by <a href="https://www.red3d.com/cwr">Craig
          Reynolds</a></p>
    </div>
  </body>
</html>
